{"version":3,"file":"virtual-list.mjs","sources":["../../../../src/components/virtual-list/virtual-list.tsx"],"sourcesContent":["import classNames from 'classnames';\nimport React, {\n    useRef,\n    useState,\n    useEffect,\n    useMemo,\n    useCallback,\n} from 'react';\nimport './style.scss';\n\ninterface ItemMetaData {\n    size: number;\n    offset: number;\n    column?: number;\n}\n\ninterface MeasuredData {\n    measuredDataMap: Record<number, ItemMetaData>;\n    lastMeasuredItemIndex: number;\n}\n\nexport interface VirtualListProps {\n    /** 列表数据 */\n    items: any[];\n    /** 容器高度 */\n    height: number;\n    /** 列数 */\n    columnCount?: number;\n    /** 预估的每项高度 */\n    estimatedItemHeight?: number;\n    /** 缓冲区大小 */\n    overscan?: number;\n    /** 加载更多的触发阈值 */\n    loadMoreThreshold?: number;\n    /** 加载更多回调 */\n    onLoadMore?: () => void;\n    /** 渲染每一项的函数 */\n    renderItem: (item: any, index: number) => React.ReactNode;\n    /** 是否正在加载更多 */\n    isLoading?: boolean;\n    /** 类名 */\n    className?: string;\n    /** 布局模式 - 瀑布流或者列表 */\n    mode?: 'waterfall' | 'list';\n}\n\nexport const VirtualList: React.FC<VirtualListProps> = ({\n    items,\n    height,\n    columnCount = 1,\n    mode = 'list',\n    estimatedItemHeight = 50,\n    overscan = 3,\n    loadMoreThreshold = 100,\n    onLoadMore,\n    renderItem,\n    isLoading = false,\n    className,\n}) => {\n    const containerRef = useRef<HTMLDivElement>(null);\n    const [scrollTop, setScrollTop] = useState(0);\n    const [resizeCount, setResizeCount] = useState(0);\n\n    // 将measuredData移到组件内部\n    const measuredDataRef = useRef<MeasuredData>({\n        measuredDataMap: {},\n        lastMeasuredItemIndex: -1,\n    });\n\n    // 添加列高度追踪\n    const columnHeights = useRef<number[]>([]);\n\n    // 初始化列高度\n    useEffect(() => {\n        columnHeights.current = new Array(columnCount).fill(0);\n    }, [columnCount]);\n\n    // 添加items变化的处理\n    useEffect(() => {\n        // 重置测量数据\n        measuredDataRef.current = {\n            measuredDataMap: {},\n            lastMeasuredItemIndex: -1,\n        };\n        // 重置列高度\n        columnHeights.current = new Array(columnCount).fill(0);\n        // 触发重新渲染\n        setResizeCount((c) => c + 1);\n    }, [items, columnCount]);\n\n    // 估算总高度\n    const estimateTotalHeight = useCallback(() => {\n        const { measuredDataMap, lastMeasuredItemIndex } =\n            measuredDataRef.current;\n        let measuredHeight = 0;\n        let estimatedHeight = 0;\n\n        if (lastMeasuredItemIndex >= 0) {\n            const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n            measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;\n        }\n\n        const unmeasuredItemsCount = items.length - (lastMeasuredItemIndex + 1);\n        estimatedHeight =\n            measuredHeight + unmeasuredItemsCount * estimatedItemHeight;\n\n        return estimatedHeight;\n    }, [items.length, estimatedItemHeight]);\n\n    // 修改获取item元数据的逻辑\n    const getItemMetadata = useCallback(\n        (index: number): ItemMetaData => {\n            const { measuredDataMap, lastMeasuredItemIndex } =\n                measuredDataRef.current;\n\n            if (index > lastMeasuredItemIndex) {\n                if (mode === 'waterfall') {\n                    // 瀑布流布局：找到最短的列\n                    const minHeight = Math.min(...columnHeights.current);\n                    const columnIndex =\n                        columnHeights.current.indexOf(minHeight);\n\n                    const size = estimatedItemHeight;\n                    const offset = minHeight;\n\n                    measuredDataMap[index] = {\n                        size,\n                        offset,\n                        column: columnIndex,\n                    };\n\n                    // 更新列高度\n                    columnHeights.current[columnIndex] = offset + size;\n                } else {\n                    // 列表布局：线性排列\n                    let offset = 0;\n                    if (lastMeasuredItemIndex >= 0) {\n                        const lastMeasuredItem =\n                            measuredDataMap[lastMeasuredItemIndex];\n                        offset =\n                            lastMeasuredItem.offset + lastMeasuredItem.size;\n                    }\n\n                    measuredDataMap[index] = {\n                        size: estimatedItemHeight,\n                        offset,\n                        column: 0,\n                    };\n                }\n                measuredDataRef.current.lastMeasuredItemIndex = index;\n            }\n\n            return (\n                measuredDataMap[index] || {\n                    size: estimatedItemHeight,\n                    offset: 0,\n                    column: 0,\n                }\n            );\n        },\n        [estimatedItemHeight, mode, columnCount]\n    );\n\n    // 修改可视区域计算逻辑\n    const getVisibleRange = useCallback(() => {\n        if (!containerRef.current) return { start: 0, end: 0 };\n\n        const { clientHeight, scrollTop } = containerRef.current;\n        const { measuredDataMap } = measuredDataRef.current;\n\n        // 二分查找找到第一个可见的项\n        let start = 0;\n        let end = items.length - 1;\n\n        while (start <= end) {\n            const mid = Math.floor((start + end) / 2);\n            const metadata = getItemMetadata(mid);\n            if (!metadata) {\n                start = mid + 1;\n                continue;\n            }\n            // 确保metadata存在且具有有效的offset值\n            if (typeof metadata.offset === 'undefined') {\n                start = mid + 1;\n                continue;\n            }\n\n            if (metadata.offset < scrollTop) {\n                if (metadata.offset + metadata.size > scrollTop) {\n                    start = mid;\n                    break;\n                }\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n\n        // 从找到的起始位置向后扫描，直到超出可见区域\n        let endIndex = start;\n        let currentOffset = measuredDataMap[start]?.offset || 0;\n\n        while (\n            endIndex < items.length &&\n            currentOffset < scrollTop + clientHeight\n        ) {\n            const metadata = getItemMetadata(endIndex);\n            currentOffset = metadata.offset + metadata.size;\n            endIndex++;\n        }\n\n        // 添加缓冲区\n        const startIndex = Math.max(0, start - overscan);\n        endIndex = Math.min(items.length - 1, endIndex + overscan);\n\n        return {\n            start: startIndex,\n            end: endIndex,\n        };\n    }, [items.length, overscan, getItemMetadata]);\n\n    // 处理滚动事件\n    const handleScroll = useCallback(() => {\n        if (!containerRef.current) return;\n\n        const { scrollTop, scrollHeight, clientHeight } = containerRef.current;\n        setScrollTop(scrollTop);\n\n        // 触发加载更多\n        if (\n            onLoadMore &&\n            !isLoading &&\n            scrollHeight - scrollTop - clientHeight < loadMoreThreshold\n        ) {\n            onLoadMore();\n        }\n    }, [onLoadMore, isLoading, loadMoreThreshold]);\n\n    // 修改渲染逻辑\n    const visibleContent = useMemo(() => {\n        const visibleRange = getVisibleRange();\n        const start = visibleRange ? visibleRange.start : 0;\n        const end = visibleRange ? visibleRange.end : 0;\n        const visibleItems = [];\n\n        for (let i = start; i <= end; i++) {\n            const itemMetadata = getItemMetadata(i);\n            const item = items[i];\n\n            if (!item) continue;\n\n            const itemStyle: React.CSSProperties =\n                mode === 'waterfall'\n                    ? {\n                          width: `${100 / columnCount}%`,\n                          position: 'absolute',\n                          left: `${((itemMetadata?.column || 0) * 100) / columnCount}%`,\n                          top: `${itemMetadata?.offset || 0}px`,\n                          padding: '8px',\n                          boxSizing: 'border-box',\n                      }\n                    : {\n                          position: 'absolute',\n                          left: 0,\n                          right: 0,\n                          top: `${itemMetadata?.offset || 0}px`,\n                          padding: '8px',\n                          boxSizing: 'border-box',\n                      };\n\n            visibleItems.push(\n                <div\n                    key={i}\n                    className={classNames('verney-virtual-list-item', {\n                        'verney-virtual-list-item-waterfall':\n                            mode === 'waterfall',\n                    })}\n                    data-index={i}\n                    style={itemStyle}\n                >\n                    {renderItem(item, i)}\n                </div>\n            );\n        }\n\n        return visibleItems;\n    }, [\n        items,\n        scrollTop,\n        resizeCount,\n        columnCount,\n        mode,\n        renderItem,\n        getItemMetadata,\n        getVisibleRange,\n    ]);\n\n    // 修改 ResizeObserver 回调\n    useEffect(() => {\n        if (!containerRef.current) return;\n\n        const resizeObserver = new ResizeObserver((entries) => {\n            let needsUpdate = false;\n\n            entries.forEach((entry) => {\n                const index = Number(entry.target.getAttribute('data-index'));\n                if (!isNaN(index)) {\n                    const oldSize =\n                        measuredDataRef.current.measuredDataMap[index]?.size ||\n                        0;\n                    const newSize = entry.contentRect.height;\n\n                    if (oldSize !== newSize) {\n                        const metadata =\n                            measuredDataRef.current.measuredDataMap[index];\n                        metadata.size = newSize;\n\n                        // 更新后续项的位置\n                        if (\n                            mode === 'waterfall' &&\n                            metadata.column !== undefined\n                        ) {\n                            columnHeights.current[metadata.column] +=\n                                newSize - oldSize;\n                        } else {\n                            for (\n                                let i = index + 1;\n                                i <=\n                                measuredDataRef.current.lastMeasuredItemIndex;\n                                i++\n                            ) {\n                                const item =\n                                    measuredDataRef.current.measuredDataMap[i];\n                                if (item) {\n                                    item.offset += newSize - oldSize;\n                                }\n                            }\n                        }\n                        needsUpdate = true;\n                    }\n                }\n            });\n\n            if (needsUpdate) {\n                setResizeCount((c) => c + 1);\n            }\n        });\n\n        const items = containerRef.current.getElementsByClassName(\n            'verney-virtual-list-item'\n        );\n        Array.from(items).forEach((item) => {\n            resizeObserver.observe(item);\n        });\n\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, [scrollTop, mode]);\n\n    const totalHeight = estimateTotalHeight();\n\n    return (\n        <div className=\"verney-virtual-list\">\n            <div\n                ref={containerRef}\n                className={classNames(\n                    'verney-virtual-list-container',\n                    className\n                )}\n                style={{ height, width: '100%' }}\n                onScroll={handleScroll}\n            >\n                <div\n                    className=\"verney-virtual-list-content\"\n                    style={{ height: totalHeight, width: '100%' }}\n                >\n                    <div\n                        className={classNames('verney-virtual-list-items', {\n                            'verney-virtual-list-items-waterfall':\n                                mode === 'waterfall',\n                        })}\n                        style={{ width: '100%', position: 'relative' }}\n                    >\n                        {visibleContent}\n                    </div>\n                </div>\n                {isLoading && (\n                    <div className=\"verney-virtual-list-loading\">加载中...</div>\n                )}\n            </div>\n        </div>\n    );\n};\n"],"names":["scrollTop","jsx","items","jsxs"],"mappings":"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"}