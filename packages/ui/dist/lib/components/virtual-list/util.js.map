{"version":3,"file":"util.js","sources":["../../../../src/components/virtual-list/util.ts"],"sourcesContent":["import type { VirtualListProps, measuredDataProps } from './virtual-list';\n\n// 元数据\nexport const measuredData = {\n    measuredDataMap: {},\n    lastMeasuredItemIndex: -1,\n};\n\n// 计算估计高度\nexport const estimatedHeight = (\n    defaultEstimatedItemSize = 50,\n    itemCount: number,\n    measuredData: measuredDataProps,\n) => {\n    let measuredHeight = 0;\n    const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n    // 计算已经获取过真实高度的项的高度之和\n    if (lastMeasuredItemIndex >= 0) {\n        const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n        measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.height;\n    }\n    // 未计算过真实高度的项数\n    const unMeasuredItemsCount = itemCount - measuredData.lastMeasuredItemIndex - 1;\n    // 预测总高度\n    const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;\n    console.log('===totalEstimatedHeight', totalEstimatedHeight);\n    return totalEstimatedHeight;\n};\n\n// 获取当前索引项的元数据信息\nexport const getItemMetaData = (measuredData: measuredDataProps, index: number) => {\n    // const { itemEstimatedHeight = 50 } = props;\n    const { measuredDataMap, lastMeasuredItemIndex } = measuredData;\n    // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的height和offset\n    // if (index > lastMeasuredItemIndex) {\n    //     let offset = 0;\n    //     // 计算当前能计算出来的最大offset值\n    //     if (lastMeasuredItemIndex >= 0) {\n    //         const lastMeasuredItem = measuredDataMap[lastMeasuredItemIndex];\n    //         offset += lastMeasuredItem.offset + lastMeasuredItem.height;\n    //     }\n    //     // 计算直到index为止，所有未计算过的项\n    //     for (let i = lastMeasuredItemIndex + 1; i <= index; i++) {\n    //         measuredDataMap[i] = { height: itemEstimatedHeight, offset }; // 更新元数据信息: 真实高度和offset值\n    //         offset += itemEstimatedHeight;\n    //     }\n    //     // 更新已计算的项的索引值\n    //     measuredData.lastMeasuredItemIndex = index;\n    // }\n    return measuredDataMap[index] || { height: 0, offset: 0 };\n};\n\n// 获取可视区开始的索引\nexport const getStartIndex = (\n    props: VirtualListProps,\n    scrollOffset: number,\n    measuredData: measuredDataProps,\n) => {\n    const { data } = props;\n    const itemCount = data.length;\n    let index = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const currentOffset = getItemMetaData(measuredData, index).offset; // 获取当前项的offset值\n        if (currentOffset >= scrollOffset) return index; // index从0开始遍历，直到找到第一个offset大于等于scrollOffset的项，即为可视区开始的索引\n        if (index >= itemCount) return itemCount; // 如果index已经大于等于itemCount，则返回itemCount\n        index++;\n    }\n};\n\n// 获取可视区结束的索引\nexport const getEndIndex = (\n    props: VirtualListProps,\n    startIndex: number,\n    measuredData: measuredDataProps,\n) => {\n    const { visibleHeight = 400, data, pageMode, pageModeVisibleSize = 20 } = props;\n    // 整页滚动模式\n    if (pageMode) {\n        return Math.min(startIndex + pageModeVisibleSize - 1, data.length - 1);\n    }\n    // 获取可视区内开始的项\n    const startItem = getItemMetaData(measuredData, startIndex);\n    // 可视区内最大的offset值\n    const maxOffset = startItem.offset + visibleHeight;\n    // 开始项的下一项的offset，之后不断累加此offset，知道等于或超过最大offset，就是找到结束索引了\n    let offset = startItem.offset + startItem.height;\n    // 结束索引\n    let endIndex = startIndex;\n    // 累加offset\n    while (offset <= maxOffset && endIndex < data.length - 1) {\n        endIndex++;\n        const currentItem = getItemMetaData(measuredData, endIndex);\n        offset += currentItem.height;\n    }\n    return endIndex;\n};\n\n// 获取可视区渲染的项的范围\nexport const getRangeToRender = (\n    props: VirtualListProps,\n    scrollOffset: number,\n    measuredData: measuredDataProps,\n) => {\n    const { data = [], bufferSize = 3 } = props;\n    const startIndex = getStartIndex(props, scrollOffset, measuredData);\n    const endIndex = getEndIndex(props, startIndex, measuredData);\n    return [\n        Math.max(0, startIndex - bufferSize), // 预留bufferSize的空间\n        Math.min(data.length - 1, endIndex + bufferSize),\n        startIndex,\n        endIndex,\n    ];\n};\n// 获取滚动偏移量\nexport function getOffset(props: VirtualListProps, containerRef: any) {\n    if (props.pageMode) {\n        return document.documentElement.scrollTop || document.body.scrollTop;\n    } else {\n        return containerRef?.current ? containerRef?.current?.scrollTop : 0;\n    }\n}\n// 获取容器可视区高度\nexport function getClientSize(props: VirtualListProps, containerRef: any) {\n    if (props.pageMode) {\n        return document.documentElement.clientHeight || document.body.clientHeight;\n    } else {\n        return containerRef?.current ? containerRef?.current?.clientHeight : 0;\n    }\n}\n// 获取容器滚动高度\nexport function getScrollSize(props: VirtualListProps, containerRef: any) {\n    if (props.pageMode) {\n        return document.documentElement.scrollHeight || document.body.scrollHeight;\n    } else {\n        return containerRef?.current ? containerRef?.current?.scrollHeight : 0;\n    }\n}\n// 滚动到指定位置，预设偏移量\nexport function scrollToOffset(props: VirtualListProps, containerRef: any) {\n    const { pageMode, presetOffset = 0 } = props;\n    if (!presetOffset) return;\n    if (pageMode) {\n        document.body.scrollTop = presetOffset;\n        document.documentElement.scrollTop = presetOffset;\n    } else if (containerRef?.current) {\n        containerRef.current.scrollTop = presetOffset;\n    }\n}\n// 写一个防抖函数\nexport const debounce = <T extends (...args: any[]) => void>(func: T, delay: number) => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    return (...args: Parameters<T>) => {\n        if (timeoutId) clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n            func(...args);\n        }, delay);\n    };\n};\n// 写一个节流函数\nexport const throttle = <T extends (...args: any[]) => void>(func: T, delay: number) => {\n    let lastTime = 0;\n    console.log('====throttle');\n    return (...args: Parameters<T>) => {\n        const now = Date.now();\n        if (now - lastTime >= delay) {\n            lastTime = now;\n            func(...args);\n        }\n    };\n};\n"],"names":["measuredData"],"mappings":";;AA8Ba,MAAA,kBAAkB,CAACA,eAAiC,UAAkB;AAEzE,QAAA,EAAE,iBAAiB,sBAAA,IAA0BA;AAiBnD,SAAO,gBAAgB,KAAK,KAAK,EAAE,QAAQ,GAAG,QAAQ,EAAE;AAC5D;AAGO,MAAM,gBAAgB,CACzB,OACA,cACAA,kBACC;AACK,QAAA,EAAE,SAAS;AACjB,QAAM,YAAY,KAAK;AACvB,MAAI,QAAQ;AAEZ,SAAO,MAAM;AACT,UAAM,gBAAgB,gBAAgBA,eAAc,KAAK,EAAE;AACvD,QAAA,iBAAiB,aAAqB,QAAA;AACtC,QAAA,SAAS,UAAkB,QAAA;AAC/B;AAAA,EAAA;AAER;AAGO,MAAM,cAAc,CACvB,OACA,YACAA,kBACC;AACD,QAAM,EAAE,gBAAgB,KAAK,MAAM,UAAU,sBAAsB,OAAO;AAE1E,MAAI,UAAU;AACV,WAAO,KAAK,IAAI,aAAa,sBAAsB,GAAG,KAAK,SAAS,CAAC;AAAA,EAAA;AAGnE,QAAA,YAAY,gBAAgBA,eAAc,UAAU;AAEpD,QAAA,YAAY,UAAU,SAAS;AAEjC,MAAA,SAAS,UAAU,SAAS,UAAU;AAE1C,MAAI,WAAW;AAEf,SAAO,UAAU,aAAa,WAAW,KAAK,SAAS,GAAG;AACtD;AACM,UAAA,cAAc,gBAAgBA,eAAc,QAAQ;AAC1D,cAAU,YAAY;AAAA,EAAA;AAEnB,SAAA;AACX;AAGO,MAAM,mBAAmB,CAC5B,OACA,cACAA,kBACC;AACD,QAAM,EAAE,OAAO,CAAA,GAAI,aAAa,EAAM,IAAA;AACtC,QAAM,aAAa,cAAc,OAAO,cAAcA,aAAY;AAClE,QAAM,WAAW,YAAY,OAAO,YAAYA,aAAY;AACrD,SAAA;AAAA,IACH,KAAK,IAAI,GAAG,aAAa,UAAU;AAAA;AAAA,IACnC,KAAK,IAAI,KAAK,SAAS,GAAG,WAAW,UAAU;AAAA,IAC/C;AAAA,IACA;AAAA,EACJ;AACJ;AAEgB,SAAA,UAAU,OAAyB,cAAmB;;AAClE,MAAI,MAAM,UAAU;AAChB,WAAO,SAAS,gBAAgB,aAAa,SAAS,KAAK;AAAA,EAAA,OACxD;AACH,YAAO,6CAAc,YAAU,kDAAc,YAAd,mBAAuB,YAAY;AAAA,EAAA;AAE1E;AAkBgB,SAAA,eAAe,OAAyB,cAAmB;AACvE,QAAM,EAAE,UAAU,eAAe,EAAM,IAAA;AACvC,MAAI,CAAC,aAAc;AACnB,MAAI,UAAU;AACV,aAAS,KAAK,YAAY;AAC1B,aAAS,gBAAgB,YAAY;AAAA,EAAA,WAC9B,6CAAc,SAAS;AAC9B,iBAAa,QAAQ,YAAY;AAAA,EAAA;AAEzC;AAYa,MAAA,WAAW,CAAqC,MAAS,UAAkB;AACpF,MAAI,WAAW;AACf,UAAQ,IAAI,cAAc;AAC1B,SAAO,IAAI,SAAwB;AACzB,UAAA,MAAM,KAAK,IAAI;AACjB,QAAA,MAAM,YAAY,OAAO;AACd,iBAAA;AACX,WAAK,GAAG,IAAI;AAAA,IAAA;AAAA,EAEpB;AACJ;;;;;;;;"}